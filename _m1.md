Это огромный список — по сути, весь алфавит байт-кода JVM. Чтобы тебе было проще, я разбил их на логические группы. Как Senior-разработчик, я сосредоточусь на тех, что критически важны для твоего компилятора `DensityFunction`.

---

### 1. Группа CONST (Константы)

Используются для загрузки простых чисел на стек. Короткие инструкции (1 байт) работают быстрее, чем `LDC`.

* **NOP (No Operation):** Ничего не делает. Используется для выравнивания или как заглушка.
* **ACONST_NULL:** Кладет `null` на стек.
* **ICONST_M1...5:** Кладут целые числа от -1 до 5 на стек.
* **LCONST_0, 1:** Кладут `long` (0 или 1).
* **FCONST_0, 1, 2:** Кладут `float` (0.0, 1.0, 2.0).
* **DCONST_0, 1:** **(Важно для тебя)** Кладут `double` 0.0 или 1.0. Самый быстрый способ загрузить эти значения в `compute`.

---

### 2. Группа PUSH & LDC (Загрузка произвольных чисел)

Если числа нет в списке `CONST`, используем их.

* **BIPUSH (Byte Push):** Кладет число от -128 до 127.
* **SIPUSH (Short Push):** Кладет число от -32768 до 32767.
* **LDC (Load Constant):** **(Важно)** Самый частый гость. Используется для загрузки любых `double` (например, `0.5` или `xzScale`), строк или ссылок на классы.

---

### 3. Группа LOAD & STORE (Работа с переменными)

Перемещение данных между "локальными переменными" (слотами) и стеком.

* **ILOAD, LLOAD, FLOAD, DLOAD, ALOAD:** Загружают переменную из слота на стек. `DLOAD` — для double, `ALOAD` — для объектов (например, `ctx` или `this`).
* **ISTORE... ASTORE:** Сохраняют значение со стека в слот. Ты использовал `DSTORE 2` в `RangeChoice`.

---

### 4. Группа XALOAD & XASTORE (Массивы)

Работа с элементами массивов. Буква в начале — тип данных (`D` — double, `A` — объект).

* **AALOAD:** **(Важно)** Достает объект из массива объектов. Ты используешь это для `this.leaves[i]`.
* **DALOAD:** Достает `double` из массива double.
* **AASTORE / DASTORE:** Сохраняют значение в ячейку массива.

---

### 5. Группа Stack Manipulation (Манипуляция стеком)

Управление порядком тарелок в стопке без вычислений.

* **POP / POP2:** Выкинуть верхнее значение со стека. `POP2` нужен для `double/long`, так как они занимают 2 слота.
* **DUP / DUP2:** Дублировать верхнее значение. `DUP2` — для `double`.
* **SWAP:** Поменять местами два верхних значения (только для 1-слотовых типов).

---

### 6. Группа Math (Арифметика)

Твое "сердце" компилятора. Буква `D` в начале — double.

* **DADD, DSUB, DMUL, DDIV, DREM:** Сложение, вычитание, умножение, деление и остаток для `double`.
* **DNEG:** Инверсия знака (отрицание).

---

### 7. Группа Битовых операций

Работают только с `int` (`I`) и `long` (`L`).

* **ISHL, ISHR, IUSHR:** Сдвиги влево/вправо.
* **IAND, IOR, IXOR:** Логические И, ИЛИ, Исключающее ИЛИ.

---

### 8. Группа Type Conversion (Приведение типов)

* **I2D:** **(Важно)** Переводит `int` в `double`. Ты используешь это для `blockX()`.
* **D2I:** Переводит `double` в `int` (отсечение дробной части).

---

### 9. Группа Comparisons (Сравнения)

* **LCMP, FCMPL/G, DCMPL/G:** Сравнивают два числа на стеке и кладут `int` (-1, 0, или 1).
* **DCMPL:** Если встретит `NaN`, вернет -1.
* **DCMPG:** Если встретит `NaN`, вернет 1.



---

### 10. Группа Jumps (Переходы/Ветвления)

* **IFEQ, IFNE, IFLT, IFGE, IFGT, IFLE:** Сравнивают `int` на стеке с нулем и прыгают на метку.
* **IF_ICMPEQ...:** Сравнивают два `int` между собой.
* **GOTO:** **(Важно)** Безусловный прыжок. Нужен, чтобы перепрыгнуть ветку `else`.
* **TABLESWITCH / LOOKUPSWITCH:** Используются для эффективных `switch` в Java.

---

### 11. Группа RETURN (Возврат из метода)

* **I... D... ARETURN:** Возврат значения соответствующего типа.
* **DRETURN:** Твой финал в методе `compute`.
* **RETURN:** Возврат из метода `void` (например, из `<init>`).

---

### 12. Группа Fields & Methods (Поля и Методы)

* **GETSTATIC / PUTSTATIC:** Работа со статическими полями.
* **GETFIELD / PUTFIELD:** **(Важно)** Чтение/запись полей объекта. Используешь для `this.leaves`.
* **INVOKEVIRTUAL:** Обычный вызов метода объекта.
* **INVOKESPECIAL:** Вызов конструктора или приватного метода.
* **INVOKESTATIC:** Вызов статического метода (например, `Math.max`).
* **INVOKEINTERFACE:** **(Важно)** Вызов метода через интерфейс (например, `ctx.blockX()`).

---

### 13. Группа Object & Type (Объекты и Типы)

* **NEW:** Создать новый объект (выделяет память, но не вызывает конструктор).
* **NEWARRAY / ANEWARRAY:** Создать массив.
* **CHECKCAST:** **(Важно)** Проверка типа. Нужна перед тем, как работать с объектом из `leaves[]` как с конкретной оберткой.
* **INSTANCEOF:** Проверка `obj instanceof Class`.

---

**Совет Senior-разработчика:**
При написании компилятора всегда держи в голове: `double` и `long` — это "тяжелые" типы. Они всегда занимают **2 слота** на стеке и в локальных переменных. Поэтому вместо `DUP` используй `DUP2`, а вместо `POP` — `POP2`. Если ошибешься, JVM выдаст `VerifyError`.

Какая группа команд сейчас вызывает больше всего вопросов применительно к твоим таскам?